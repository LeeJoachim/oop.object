1. 함수형 프로그래밍으로부터 얻는 힌트들

    함수형 프로그래밍 : 함수에서 계산을 꺼내려는 시도

    1-1. 추출
        데이터(data)
        액션(action)
            부수 효과(side effect)의 존재
                시점과 횟수에 의존한다.
                순서와 반복에 의존한다.
                    분산 시스템의 경우 메시지 순서와 횟수를 보장할 수 없다.
            액션은 사용되는 순간 코드 전체로 퍼져나간다.

        계산(computation), 순수 함수, 수학 함수
            같은 인자를 넣으면 항상 같은 값을 리턴한다. (불변성, 참조 투명성)

    1-1-1. 객체지향
        명령-쿼리 분리(Command-Query Separation) 원칙 : 명령과 쿼리 두 가지 역할을 동시에 수행해서는 안된다.
        루틴(routine) : 어떤 절차를 묶고, 이름을 붙여 호출될 수 있도록 함

            프로시저(procedure), 명령(command) : 반환값이 없는 루틴
                1. 객체의 상태를 수정한다. > 부수효과를 발생시킬 수 있다.

            함수(function), 쿼리(query) : 반환값이 있는 루틴
                2. 객체와 관련된 정보를 반환한다. > 부수효과를 발생시킬 수 없으므로, 순서와 횟수에서 자유롭다
        
        컴퓨터의 세계와 수학의 세계를 나누는 기준 : 부수효과
            부수효과가 존재함 : 1. 대입문, 2. 프로시저

        명령형 프로그래밍 : 순서대로 작성된
        함수형 프로그래밍 : 부수효과 최소화 > 병렬 처리 가능

    1-2. 일급 함수

        고차 함수(higher-order function)
            함수를 인자로 받거나 함수를 리턴하는 함수

            인라인 함수(inline function), 람다 표현식(lambda expression)
                인자 목록 안에 구현된 함수
                익명 함수(anonymous function)를 사용한다.

    내부의 뇌
        인지 과부하(cognitive overload)
            정보의 양을 제한

                1. 세부 사항에 대해 걱정하지 않음
                    추상화

                2. 한 번에 계산해야 할 양을 줄임
                    단순화
                        소통 경로 최소화 : 정보 전문가 패턴(Information Expert Pattern)
                        도트 최소화 : 디미터 법칙
                        위임(delegation) : 받은 메시지를 그대로 전달함
                        도메인 모델 : INFORMATION EXPERT를 찾기 위한 지도.
                        분해(decomposition) : 이해할 수 있는 작은 단위로 분해
                        좋은 메서드 : 주석같은 코드, 짧은 길이, 한 가지 일만 수행, 의도를 분명히 드러내는 이름
                        순수한 가공물, 의인화 : 설계를 단순화하기 위한 비틀기로 어색함을 비용으로 지불해야 한다.

                3. 어색한 정보의 양을 줄임
                    일관적(개념적 무결성) : 예측 가능성

    외부의 환경
        다형성(polymorphism), 유연성 및 트리구조
        다형성의 종류
            1. 오버로딩 다형성 : 동일한 이름을 허락한다.
            2. 강제 다형성 : + 연산자는 정수형과 문자열의 결합에서 문자열에 우선순위를 둔다. (강제 형변환)
            3. 매개변수 다형성 : 매개변수 타입을 사용하는 시점에 결정한다.(제네릭)
            4. 서브타입 다형성 : 동일한 메시지에 객체들이 서로 다르게 반응하도록 만든다.
        
        변화에 대한 컴파일타임 수준의 대처
            캡슐화(encapsulation) : 경로 제한 : 변경될 코드의 범위를 극소화한다.
                1. shy code : 최대한 private화
                2. 컨텍스트 독립성 : 객체는 외부를 모른다.
                3. 의존성 역전 원칙 : 추상적 상위 레벨은 구상적 하위 레벨을 모른다. 그러나 하위는 상위에 의존한다.
            
        변화에 대한 런타임 수준의 대처
            고정된 메시지는 런타임 객체 할당을 요구한다.
                합성(composition) : 상속 트리를 자신의 인스턴스 변수로 가진다: 코드 재사용
                    1. 생성자 주입
                    2. setter 주입
                    3. 1번 + 2번
                        객체는 완전한 상태로 생성되어야 한다.
                        setter 메서드를 통해 의존 대상이 변경될 수 있어야 한다.
                    4. 메서드 주입 : 특수 케이스                                
                new는 해롭다
                    1. 생성의 책임을 클라이언트, FACTORY로 옮겨라.
                    2. 생성은 추상 클래스, 인터페이스 타입에 의존하라.
                    3. 생성과 사용은 함께 있지 않도록 처리하라.(생성 사용 분리)
                런타임의 예외는 위험하게도, 실행 시점에 밝혀진다.
                    1. 명시적인 의존성(explicit dependency) : 퍼블릭 인터페이스에 노출하라.
                    2. 숨겨진 의존성(hidden dependency) : 아무것도 숨겨서는 안된다.
                불필요한 SINGLETON 패턴 : 객체 생성을 너무 일찍 생각하고 결정

            고정된 메시지는 동적 메서드 탐색을 요구한다.
                동적 메서드 탐색
                    순서(우선 순위) : this -> ... -> Object
                        오버로딩(overloading) : 수평적으로 공존
                        오버라이딩(overriding) : 우선 순위의 존재
                    .self 참조(self reference) : this
                        탐색 종료시 참조 소멸. 
                        탐색 중에 this는 변하지 않는다. 
                    .self 전송(self send) : 금지
                        this에서 다시 탐색하세요.
                    super 예약어 
                        한 칸 위의 클래스부터 탐색을 시작하세요.
                    super sending
                        객체지향 언어에서 super는 컴파일 타임에 결정되는 경우가 많다.

            고정된 메시지는 트리 구조를 요구한다.
                상속은 커다란 대가를 지불해야 한다.
                    1. super 호출은 결합도를 높인다. 
                    2. 하위 레벨이 부분집합이 될 수 없는 경우가 많다. (리스코프 치환 원칙)
                    3. 동시에 변경할 각오를 하고 사용하라.
                    4. 기록하지 않을 예정이라면 상속을 금지하라.
                    5. 코드 재사용은 무척 조심해야 한다.

                상속의 목적 : 다형성을 위한 트리를 제공, 코드 재사용, 중복 제거
                상속의 종류
                        1. 인터페이스 상속(interface inheritance), 서브타이핑(subtyping)
                            타입 계층을 구성하기 위해 사용
                            아래 층위를 캡슐화(은닉)함
                            항상 퍼블릭
                                default로 구현 상속처럼 사용해서는 안된다.
                                클라이언트에게 사용당할 것을 염두에 둔 이름짓기가 요구된다.

                        2. 추상 클래스 상속(abstract class inheritance)
                            private로 세부사항을 은닉하고, 기본 구현을 제공하는 용도로 사용
                            훅 메서드(hook method) : 기본 구현을 상위 레벨에서 정의해두는 것
                            추상 클래스(abstract class) : 불완전, 홀로 인스턴스화할 수 없다.
                
                        3. 구현 상속(implementation inheritance), 서브클래싱(subclassing) : 사용금지


    리스코프 치환 원칙 (Liskov Substitution Principle, LSP)
        슈퍼타입은 언제나 서브타입을 개념적으로 덮어야 한다. 공변성
        그렇지 않다면 맹점이 나타난다. : 범인은 법망을 피해 달아날 것이다.

        행동 호환성 : 어떤 타입이 다른 타입의 서브타입이 되기 위해서는(업캐스팅), 대체 가능해야 한다.(공변성)
        
        계약에 의한 설계 : 런타임 검증을 위함
            Object는 여러 겹으로 둘러 싸여 있다.
                (최약 사전조건)this 부터 (최강 사전조건)Object까지 탐색 : 입력이 조건 하임을 요구한다. : 조건 하라면, 메서드를 호출한다.

            트리는 추상에서 구상으로 내려간다.
                (최약 사후조건)Object 부터 (최강 사후조건)this까지 구현 : 출력은 조건 하임을 보장한다.

            불변식 : 모든 인스턴스는 불변식 하에 있어야 한다. 메서드 실행 중에는 상태가 불안정할 수 있다.

            자바는 단순한 코드를 지향하여, 지원하지 않는다.
                대안 1. 예외 처리
                대안 2. 주석 : 계약은 주석과는 다르게 실행 가능하기 때문에, 런타임에 검증할 수 있다.

        프레임워크 : 코드를 재사용하기 위한 기반 코드를 포함한다.
            의존성 역전 원리. 제어 역전 원리, 할리우드 원리 : 프레임워크의 가장 기본적인 설계 메커니즘이다.
            
            프레임워크는 자신을 찾지 말라고 이야기한다. 프레임워크가 찾을 것이다.
            프레임워크가 우리의 코드를 호출해줄 때까지 기다리라고 이야기한다.
            우리는 그저 프레임워크가 호출하는 코드를 작성해야 한다.
            제어 흐름이 손가락 사이로 스멀스멀 빠져나가는 듯한 느낌에 불안해질 것이다.
            그러나 이러한 불안이 재사용을 가능하게 하는 힘이다.
            
        TYPE OBJECT 패턴 : 타입이 인터페이스나 클래스로 명시적으로 보이지 않고, 클래스 변수에 할당된 객체의 종류에 따라서 구분될 수 있는 패턴
        
    

